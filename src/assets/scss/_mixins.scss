@use "sass:math";
@use "sass:meta";
@use "sass:list";

@function px-to-rem($value, $base: 16) {
  @if math.is-unitless($value) {
    $value: $value * 1px;
  }

  @if math.unit($value) != "px" {
    @error "px-to-rem expects pixel values, got #{math.unit($value)}.";
  }

  $unitless-value: math.div($value, 1px);
  @return math.div($unitless-value, $base) * 1rem;
}

// ✅ 단일/리스트 모두 처리하는 px()
@function px($values..., $base: 16) {
  // 값이 1개고 그게 리스트면(예: px((20 15 10 5))) 풀어줌
  @if list.length($values) == 1 and meta.type-of(list.nth($values, 1)) == "list" {
    $values: list.nth($values, 1);
  }

  $out: ();
  @for $i from 1 through list.length($values) {
    $v: list.nth($values, $i);

    // 0은 rem 변환해도 의미 없어서 그대로 0
    @if $v == 0 {
      $out: list.append($out, 0, space);
    } @else {
      $out: list.append($out, px-to-rem($v, $base), space);
    }
  }

  // 값이 1개면 단일로 반환, 여러 개면 shorthand 리스트 반환
  @return if(list.length($out) == 1, list.nth($out, 1), $out);
}

// 기존 믹스인은 그대로 써도 됨 (단일 값용)
@mixin px($property, $value, $max: null, $base: 16, $max-property: null) {
  #{$property}: px($value, $base: $base);

  @if $max != null {
    @if $max-property == null {
      $max-property: unquote("max-#{$property}");
    }
    #{$max-property}: px($max, $base: $base);
  }
}
